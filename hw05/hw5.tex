\documentclass[11pt]{article}

\newcommand{\yourname}{}
\newcommand{\yourcollaborators}{}

\def\comments{0}

%format and packages%\usepackage{algorithm, algorithmic}
\usepackage{algpseudocode}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{enumerate}
\usepackage{enumitem}
\usepackage{framed}
\usepackage{verbatim}
\usepackage[margin=1.0in]{geometry}
\usepackage{multirow}

\usepackage{microtype}


\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{automata, positioning, arrows.meta}

	\definecolor{processblue}{cmyk}{0.96,0,0,0}


\usepackage{kpfonts}
\usepackage{palatino}
	\DeclareMathAlphabet{\mathtt}{OT1}{cmtt}{m}{n}
	\SetMathAlphabet{\mathtt}{bold}{OT1}{cmtt}{bx}{n}
	\DeclareMathAlphabet{\mathsf}{OT1}{cmss}{m}{n}
	\SetMathAlphabet{\mathsf}{bold}{OT1}{cmss}{bx}{n}
	\renewcommand*\ttdefault{cmtt}
	\renewcommand*\sfdefault{cmss}
	\renewcommand{\baselinestretch}{1.06}
\usepackage{tikz}
	\usetikzlibrary{positioning}
	\definecolor{processblue}{cmyk}{0.96,0,0,0}
    \usetikzlibrary{matrix,arrows}

\tikzset{
->, % makes the edges directed
>=Stealth, % makes the arrow heads bold
node distance=3cm, % specifies the minimum distance between two nodes. Change if necessary.
every state/.style={thick, fill=gray!10}, % sets the properties for each ’state’ node
initial text=$ $, % sets the text that appears on the start arrow
}
	
\usepackage{hyperref}

\hypersetup{
	linktocpage=true,
	colorlinks=true,				% false: boxed links; true: colored links
	linkcolor=blue,		% color of internal links
	citecolor=blue,	% color of links to bibliography
	urlcolor=blue,		% color of external links
}

\usepackage[boxruled,vlined,nofillcomment]{algorithm2e}
	\SetKwProg{Fn}{Function}{\string:}{}
	\SetKwFor{While}{While}{}{}
	\SetKwFor{For}{For}{}{}
	\SetKwIF{If}{ElseIf}{Else}{If}{:}{ElseIf}{Else}{:}
	\SetKw{Return}{Return}

%enclosure macros
\newcommand{\paren}[1]{\ensuremath{\left( {#1} \right)}}
\newcommand{\bracket}[1]{\ensuremath{\left\{ {#1} \right\}}}
\renewcommand{\sb}[1]{\ensuremath{\left[ {#1} \right\]}}
\newcommand{\ab}[1]{\ensuremath{\left\langle {#1} \right\rangle}}

%probability macros
\newcommand{\ex}[2]{{\ifx&#1& \mathbb{E} \else \underset{#1}{\mathbb{E}} \fi \left[#2\right]}}
\newcommand{\pr}[2]{{\ifx&#1& \mathbb{P} \else \underset{#1}{\mathbb{P}} \fi \left[#2\right]}}
\newcommand{\var}[2]{{\ifx&#1& \mathrm{Var} \else \underset{#1}{\mathrm{Var}} \fi \left[#2\right]}}

%useful CS macros
\newcommand{\poly}{\mathrm{poly}}
\newcommand{\polylog}{\mathrm{polylog}}
\newcommand{\zo}{\{0,1\}}
\newcommand{\pmo}{\{\pm1\}}
\newcommand{\getsr}{\gets_{\mbox{\tiny R}}}
\newcommand{\card}[1]{\left| #1 \right|}
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\negl}{\mathrm{negl}}
\newcommand{\eps}{\varepsilon}
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}
\newcommand{\eqand}{\qquad \textrm{and} \qquad}
\newcommand{\ind}[1]{\mathbb{I}\{#1\}}
\newcommand{\sslash}{\ensuremath{\mathbin{/\mkern-3mu/}}}

%mathbb
\newcommand{\N}{\mathbb{N}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Z}{\mathbb{Z}}
%mathcal
\newcommand{\cA}{\mathcal{A}}
\newcommand{\cB}{\mathcal{B}}
\newcommand{\cC}{\mathcal{C}}
\newcommand{\cD}{\mathcal{D}}
\newcommand{\cE}{\mathcal{E}}
\newcommand{\cF}{\mathcal{F}}
\newcommand{\cL}{\mathcal{L}}
\newcommand{\cM}{\mathcal{M}}
\newcommand{\cO}{\mathcal{O}}
\newcommand{\cP}{\mathcal{P}}
\newcommand{\cQ}{\mathcal{Q}}
\newcommand{\cR}{\mathcal{R}}
\newcommand{\cS}{\mathcal{S}}
\newcommand{\cU}{\mathcal{U}}
\newcommand{\cV}{\mathcal{V}}
\newcommand{\cW}{\mathcal{W}}
\newcommand{\cX}{\mathcal{X}}
\newcommand{\cY}{\mathcal{Y}}
\newcommand{\cZ}{\mathcal{Z}}

\newcommand{\opt}{\textsc{opt}}

%theorem macros
\newtheorem{thm}{Theorem}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{fact}[thm]{Fact}
\newtheorem{clm}[thm]{Claim}
\newtheorem{rem}[thm]{Remark}
\newtheorem{coro}[thm]{Corollary}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{conj}[thm]{Conjecture}

\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}


\newcommand{\instructor}{Drew van der Poel}
\newcommand{\hwnum}{5}
\newcommand{\hwdue}{Saturday, August 13 at 11:59pm via \href{https://www.gradescope.com/courses/406943}{Gradescope}}

\theoremstyle{theorem}
\newtheorem{prob}{Problem}
\newtheorem{sol}{Solution}

\definecolor{cit}{rgb}{0.05,0.2,0.45} 
\newcommand{\solution}{\medskip\noindent{\color{blue}\textbf{Solution:}}}

\begin{document}
{\Large 
\begin{center}{CS3800: Theory of Computation} --- Summer II '22 --- \instructor \end{center}}
{\large
\vspace{10pt}
\noindent Homework~\hwnum \vspace{2pt}\\
Due~\hwdue}

\bigskip
{\large
\noindent Name: \yourname \vspace{2pt}\\ Collaborators: \yourcollaborators}

\vspace{15pt}
\begin{itemize}

\item Make sure to put your name on the first page.  If you are using the \LaTeX~template we provided, then you can make sure it appears by filling in the \texttt{yourname} command.

\item This assignment is due~\hwdue.  No late assignments will be accepted.  Make sure to submit something before the deadline.

\item Solutions must be typeset.  If you need to draw any diagrams, you may draw them by hand as long as they are embedded in the PDF.  I recommend using the source file for this assignment to get started.

\item I encourage you to work with your classmates on the homework problems. \emph{If you do collaborate, you must write all solutions by yourself, in your own words.}  Do not submit anything you cannot explain.  Please list all your collaborators in your solution for each problem by filling in the \texttt{yourcollaborators} command.

\item Finding solutions to homework problems on the web, or by asking students not enrolled in the class is strictly forbidden.

\end{itemize}




\newpage

\begin{prob} Multi-Automata Decidability (\emph{8 points})\end{prob}

For each of the following languages, state whether or not they are decidable. If a language is decidable, give a proof (description of an algorithm) showing why. If not, give an argument as to how this would contradict one of the undecidability results we saw in class.

\begin{enumerate}[label=(\alph*)]


\item \textbf{[4 pts.]} $L_1 = \{ \langle P, T, w \rangle |$ P is a PDA, T is a Turing Machine, w is an input string and at least one of P or T accepts w$\}$

\solution \\
$L_1$ is undecidable - \\~\\
Assume true, that $L_1$ is decidable so there exists a Turing Machine, $T_1$, that decides $L_1$. \\~\\
\noindent Let $S$ be a Turing Machine that takes in the same input as $A_{TM}$ (the Turing Machine acceptance problem), $<M, w'>$. \\~\\
\noindent On input $\langle M, w' \rangle$ for S: \\~\\
1. Construct a PDA, $E$, s.t. $L(E) = \varnothing$: \\~\\
2. Run $T_1$ on inputs $<E, M, w'>$. If $T_1$ accepts then $S$ should accept otherwise if $T_1$ rejects then $S$ should reject. \\~\\
This means that with the help of Turing Machine $T_1$ there exists the Turing Machine $S$ that decides $A_{TM}$ which is a contradiction since $A_{TM}$ is undecidable. This means that $T_1$ cannot exist which means that $L_5$ is undecidable. \\~\\
Explanation: \\~\\
The idea behind this proof is that if PDA $P$ rejects on all inputs then that means $L_1$ essentially boils down to $A_{TM}$, the Turing Machine Acceptance problem problem. Since we know that $A_{TM}$ is undecidable then we know that if $L_1$ exists then we could construct a Turing Machine that decides $A_{TM}$ which is a contradiction since $A_{TM}$ is undecidable.


\newpage
\item \textbf{[4 pts.]} $L_2 = \{ \langle N, G \rangle |$ N is a NFA, G is a CFG, and $L(N) = L(G) = \emptyset \}$

\solution 

$L_2$ is a decidable language. Let $T_2$ be the Turing Machine on $L_2$. On input $\langle N, G \rangle$: \\~\\
\begin{minipage}{.9\textwidth}
	1. Convert NFA $N$ to the equivalent DFA, $N_{DFA}$, and run TM $D_{E-DFA}$ on $N_{DFA}$. \\~\\
	2. If $D_{E-DFA}$ rejects then $T_2$ should reject. \\~\\
	3. If $D_{E-DFA}$ accepts then run TM $D_{E-CFG}$ on CFG $G$. \\~\\
	4. If $D_{E-CFG}$ rejects then $T_2$ should reject. \\~\\
	5. If $D_{E-CFG}$ accepts then $T_2$ should accept. \\~\\
\end{minipage}

Explanation:\\~\\
Step 1: TM $D_{E-DFA}$ is the Turing Machine that decides the emptiness problem for DFAs so this step halts. \\~\\
Step 3: TM $D_{E-CFG}$ is the Turing Machine that decides the emptiness problem for CFGs so this step halts. \\~\\
We want to know if both $<N, G>$ are empty so we need both $D_{E-DFA}$ and $D_{E-CFG}$ to accept. Therefore, if at any point one of them rejects then we want $T_2$ to reject.









\end{enumerate}


\newpage

\begin{prob} Proving Undecidability with Reducibility (\emph{8 points})\end{prob}

Consider the following language, 

$L_{5} = \{\langle M \rangle | ~M $  is a Turing machine and there is a string of length 5 in~$ L(M)\}$\\

Prove that $L_{5}$ is undecidable with a reducibility argument, using $A_{TM}$, the Turing machine-acceptance problem.

\solution

\noindent Assume false, $L_{5}$ is decidable so there exists a Turing Machine, $A$, that decides $L_{5}$. \\~\\
\noindent Let $S$ be a Turing Machine that takes in the same input as $A_{TM}$, $<M', w>$. \\~\\
\noindent On input $\langle M', w \rangle$ for S: \\~\\
\hangindent=0.7cm 1. Construct a TM, $B$, s.t. on input $\langle X \rangle$: \\~\\
\hspace*{0.9cm}
\begin{minipage}{.8\textwidth}
		1a. Run $M'$ on $w$: \\~\\
		\indent If $M'$ accepts then $B$ will accept. ($L(B) = \Sigma$* so $L(B)$ must include some string of length 5 if $M'$ accepts $w$)  \\~\\
		\indent If $M'$ rejects then $B$ will reject. ($L(B) = \varnothing$ so $L(B)$ does not include any strings of length 5 if $M'$ rejects $w$) \\~\\
\end{minipage}

2. Run $A$ on $B$: \\~\\
\hspace*{0.9cm}
\begin{minipage}{.8\textwidth}
2a. If $A$ accepts (this means that $M'$ has accepted $w$ which means that $L(B)$ has to include some string of length 5) then $S$ will accept. \\~\\
2b. If $A$ rejects (this means that $M'$ has rejected $w$ so $L(B)$ is the empty set) then $S$ will reject. \\~\\
\end{minipage}

\noindent This means that with the help of Turing Machine $A$ there exists the Turing Machine $S$ that decides $A_{TM}$ which is a contradiction since $A_{TM}$ is undecidable. This means that $A$ cannot exist which means that $L_5$ is undecidable.




\newpage


\begin{prob} Diagonalization (\emph{4 points}) \end{prob}

Recall the emptiness problem for Turing machines, $E_{TM}$. We showed in class that  $E_{TM}$ is undecidable via being reducible from $A_{TM}$. Now you're asked to construct an alternative proof of $E_{TM}$ being undecidable, using a \emph{diagonalization argument}. 

\solution\\
Assume false, $E_{TM}$ is decidable so there exists some Turing Machine, $H$, that decides $E_{TM}$. \\~\\
$H$ on $<M>$, where $M$ is some Turing Machine, will: \\
1. Accept if $L(M) = \varnothing$ \\
2. Reject if $L(M) \neq \varnothing$ \\~\\
Let $E$ be some decider TM that takes in input $<M'>$ where $M'$ is some Turing Machine. \\~\\
E = On input $<M'>$:\\~\\
\hspace*{0.5cm}
\begin{minipage}{1.8\textwidth}
	1. Run $E$ on $M'$ \\~\\
	2. If $H$ accepts then $E$ accepts and if $H$ rejects then $E$ rejects\\
\end{minipage}

\noindent $E$ accepts $<M'>$ iff $L(M') = \varnothing$. \\
So if we run $E$ on $<E>$ then $E$ accepts $<E>$ iff $L(E) = \varnothing$. \\~\\
\noindent This is the contradiction here since $E$ only accepts itself if the $L(E) = \varnothing$ which is impossible because if $E$ accepts itself then $L(E)$ cannot be empty since it contains at least $E$ in its language but this can only happen if $L(E)$ is empty. Thus by contradiction, $H$ cannot exist since it would allow the existence of $E$ which means that $E_{TM}$ is undecidable. 



\newpage

\begin{prob} We've Seen This Language Before.... (\emph{6 points})\end{prob}

Recall from earlier, $L_{5} = \{\langle M \rangle | ~M $  is a Turing machine and there is a string of length 5 in~$ L(M)\}$.

Prove that $\overline{L_{5}}$ is unrecognizable. You should not use a reduction in your proof.



\solution

\noindent We must first show that $L_{5}$ is Turing-recognizable: \\~\\
\hspace*{0.9cm}
\begin{minipage}{1.8\textwidth}
Let $T_{5}$ be the Turing Machine on $L_{5}$. On input $\langle M \rangle$: \\
\hspace*{1.2cm}
\begin{minipage}{1.8\textwidth}
\vspace*{0.5cm}
1. Let $w_{1}, w_{2}, w_{3} ...$ be the list of all strings in $\Sigma$* \\~\\
2. For $i = 1, 2, 3...$ : \\~\\
	\hspace*{0.8cm}
	\begin{minipage}{0.75\textwidth}
	2a. Run $M$ for $i$ steps on the first $w_{1}, w_{2}, w_{3} ... w_{i}$ strings. \\~\\
	2b. If $M$ accepts some string $w_{j}$ where $1 \leq j \leq i$ and the length of $w_{j}$ is 5 then $T_{5}$\\ 
		should accept. Otherwise, continue the loop. \\ 
	\vspace*{0.5cm}	
	\end{minipage}
\end{minipage}
\end{minipage}

\noindent$T_{5}$ will accept at some point if $L(M)$ contains some string that is of length 5 or $T_{5}$ will reject by looping if $L(M)$ does not contain any strings of length 5. Thus, $L_{5}$ is a Turing-recognizable language. \\~\\
We've proven that $L_{5}$ is Turing-recognizable from the above algorithm but it is not Turing-decidable from a problem. By the theorem that a language is decidable if and only if it is both Turing-recognizable and co-Turing-recognizable. Then since we know that $L_{5}$ is Turing-recognizable but not decidable then that means $\overline{L_{5}}$ must not be Turing-recognizable.



\newpage

\begin{prob} Thought Experiment (\emph{4 points})\end{prob}

In class we saw how to reduce $A_{TM}$ to $HALT_{TM}$ to show $HALT_{TM}$ was undecidable. Suppose the roles were reversed, you know $HALT_{TM}$ is undecidable and want to use proof by contradiction to show $A_{TM}$ is also undecidable.

Note that this is a thought experiment and the application doesn't make sense, as we used the undecidability of $A_{TM}$ to prove that $HALT_{TM}$ was undecidable. So for our purposes (if it makes you happier), you can imagine $HALT_{TM}$ has somehow (magically) been shown to be undecidable but $A_{TM}$ has not.

\begin{enumerate}[label=(\alph*)]


\item \textbf{[1/2 pt.]} We are proving by contradiction. What is your initial assumption? What does this imply in terms of the existence of some Turing machine(s)? What is the input to that Turing machine?

\solution

We initially assume false, that $A_{TM}$ is decidable so there exists a Turing Machine, $T$, that decides the $A_{TM}$ problem. The input to $T$ would be $<M, w>$ where $M$ is some Turing Machine and $w$ is some string. 


\item \textbf{[1/2 pt.]} What are the possible outcomes of your above Turing machine on some input and what does each outcome mean?

\solution

ACCEPTS INPUT OR REJECTS INPUT EITHER BY HALTING OR looping



\item \textbf{[2 pts.]} At least one of the outcomes above isn't helpful in concluding anything about $HALT_{TM}$. Identify any such outcome and explain why it doesn't  allow us to draw conclusions about $HALT_{TM}$?

\solution

rejecting - we don't know if M rejects by halting or looping


\item \textbf{[1 pt.]} Part (c) tells us this proof wouldn't work. But for the sake of exercise, for each remaining outcome from part (b), explain why this does allow us to draw conclusions about $HALT_{TM}$.

\solution


REJECTING IS NOT useful


\end{enumerate}


\end{document}
